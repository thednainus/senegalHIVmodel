THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.tree,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3,
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 41)
return(mll)
}
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 20, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/10, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/10, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
sampler <-  function(n=1){
d1 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp0
d2 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp1
d3 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp2
d4 = runif(n, min = 1978, max = 2014) #gpsploc
d5 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp0
d6 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp1
d7 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp2
d8 = runif(n, min = 1978, max = 2014) #msmsploc
d9 = rexp(n, rate = 30) #import
d10 = rexp(n, rate = 20) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = rexp(n, rate = 1/10) #initmsm
d14 = rexp(n, rate = 1/10) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0, 0, 0, 1978, 0, 0, 0, 1978, 0, 0.0001, 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 0.30, 1, 1, 300, 300))
runZ=readRDS("newPrior_runWithStartValue1.rds")
r1=reaRDS("z_andInitialValues2.RDS")
r1=readRDS("z_andInitialValues2.RDS")
quartz()
par(ask=T)
plot(r1)
plot(r1,start=800)
runZ=readRDS("newPrior_runWithStartValue1.rds")
x <- getSample(runZ, start=3000)
rangePost = apply(x, 2, range)
rangePost
u_x <- unique(x)
str(u_x)
newZ = matrix(runif(1960, rangePost[1,], rangePost[2,]), ncol = 14, byrow = T)
pos1=1
pos2=100
pos3=108
iter=6000 # number of iterations
u_x[c(pos1, pos2, pos3), ]
plot(runZ, start=3000)
settings = list(Z = newZ, startValue =  u_x[c(pos1, pos2, pos3), ], nrChains = 1, iterations = iter, thin = 1)
settings
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
seed <- as.integer(runif(n = 1, min = 1, max = 10000))
message(seed)
set.seed(seed)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
quartz()
par(ask=T)
plot(runZ)
plot(runZ,start=1000)
seed <- as.integer(runif(n = 1, min = 1, max = 10000))
message(seed)
set.seed(seed)
runZ
names(runZ)
runZ$setup
runZ$settings
summary(runZ)
runz2 <- runMCMC(runZ)
saveRDS(runz2, "runz2.rds")
summary(runz2)
quartz()
par(ask=T)
plot(runz2)
plot(runz2,start=2000)
plot(runz2,start=4000)
plot(runz2,start=4500)
summary(runz2,start=4000)
library(senegalHIVmodel)
library(senegalHIVmodel)
source("analyses/scripts/model.R")
source("analyses/scripts/load_data.R")
obj_fun <- function(parameters){
# we use unname here because "parameters" can be as vectors or matrix, and
# sometimes it comes with column names, which I chose to remove these column names
# in here.
parameters <- unname(parameters)
# add the values of THETA to a new variable named THETA.new
THETA.new <- THETA
# change the values in THETA.new to the new proposals that will be evaluated
THETA.new$gpsp0 <- parameters[1]
THETA.new$gpsp1 <- parameters[2]
THETA.new$gpsp2 <- parameters[3]
THETA.new$gpsploc <- parameters[4]
THETA.new$msmsp0 <- parameters[5]
THETA.new$msmsp1 <- parameters[6]
THETA.new$msmsp2 <- parameters[7]
THETA.new$msmsploc <- parameters[8]
THETA.new$import <- parameters[9]
THETA.new$srcNe <- parameters[10]
THETA.new$pmsm2msm <- parameters[11]
THETA.new$pgpf2gpm <- parameters[12]
THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.tree,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3,
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 41)
return(mll)
}
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 20, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/10, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/10, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
sampler <-  function(n=1){
d1 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp0
d2 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp1
d3 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp2
d4 = runif(n, min = 1978, max = 2014) #gpsploc
d5 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp0
d6 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp1
d7 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp2
d8 = runif(n, min = 1978, max = 2014) #msmsploc
d9 = rexp(n, rate = 30) #import
d10 = rexp(n, rate = 20) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = rexp(n, rate = 1/10) #initmsm
d14 = rexp(n, rate = 1/10) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0, 0, 0, 1978, 0, 0, 0, 1978, 0, 0.0001, 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 0.30, 1, 1, 300, 300))
runZ <- readRDS("runz2.rds")
x <- getSample(runZ, start=4000)
rangePost = apply(x, 2, range)
rangePost
u_x <- unique(x)
str(u_x)
pos1=212
pos2=213
pos3=214
iter=6000 # number of iterations
u_x[c(pos1, pos2, pos3), ]
pos1=1
pos2=10
pos3=214
u_x[c(pos1, pos2, pos3), ]
u_x
iter=6000 # number of iterations
settings = list(Z = newZ, startValue =  u_x[c(pos1, pos2, pos3), ], nrChains = 1, iterations = iter, thin = 1)
newZ = matrix(runif(1960, rangePost[1,], rangePost[2,]), ncol = 14, byrow = T)
settings = list(Z = newZ, startValue =  u_x[c(pos1, pos2, pos3), ], nrChains = 1, iterations = iter, thin = 1)
settings
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
summary(outZ)
quartz()
plot(outZ)
par(ask=T)
plot(outZ)
plot(outZ,start=500)
library(phydynR)
library(akima)
demes <- c('gpm', 'gpf', 'msm', 'src')
eqns <- setup.model.equations(demes)
library(senegalHIVmodel)
eqns <- setup.model.equations(demes)
attach(eqns)
T0 <- 1978
T1 <- 2014
GAMMA <- 1/10
THETA <- list(
gpsp0 = 0.56,
gpsp1 = 0.80,
gpsp2 = 0.31,
gpsploc = 1980.78,
msmsp0 = 0.91,
msmsp1 = 0.30,
msmsp2 = 0.12,
msmsploc = 1998.029,
maleX = 1.02,
import = 0.06,
srcNe = 0.29,
gpspline = function( t, parms ){
if (t < T0 ) return( parms$gpsp0 )
if (t > T1) return (parms$gpsp2)
with(parms, aspline( x = c(T0,gpsploc,T1), y=c(gpsp0,gpsp1,gpsp2) , xout = t)$y )
},
msmspline  = function( t, parms){
if (t < T0 ) return( parms$msmsp0 )
if (t > T1) return ( parms$msmsp2 )
with(parms, aspline( x = c(T0,msmsploc,T1), y=c(msmsp0,msmsp1,msmsp2) , xout = t)$y )
},
pmsm2msm = 0.99,
pgpf2gpm = 0.48,
initmsm = 254.83,
initgp = 16.37
)
show.demographic.process.mod <- function (demo.model, theta, x0, t0, t1, res = 1000, integrationMethod = "lsoda", ...)
{
tfgy <- demo.model(theta, x0, t0, t1, res = 1000, integrationMethod = integrationMethod)
o <- tfgy[[5]]
t <- o[, 1]
if (((ncol(o) - 1) == 2) & tail(colnames(o), 1) == "V2") {
plot(t, o[, 2], type = "l", xlab = "Time", ylab = colnames(o)[2],
...)
}
else {
matplot(t, o[, 2:ncol(o)], type = "l", xlab = "Time",
ylab = "", ...)
legend("topleft", inset = 0.05, legend = colnames(o)[2:ncol(o)],
pch = 1, col = 1:(ncol(o) - 1), horiz = TRUE)
}
}
SRCSIZE <<- 1e5 # arbitrary large number > A(t) forall t
X0 <- c( gpm = unname( THETA$initgp/2 ), gpf = unname( THETA$initgp/2), msm = unname( THETA$initmsm ) , src = SRCSIZE)
X0
births['msm', 'msm'] <- 'parms$msmspline( t, parms ) * msm * parms$pmsm2msm'
births['msm', 'gpf'] <- 'parms$msmspline( t, parms ) * msm * (1-parms$pmsm2msm)'
births['gpm', 'gpf'] <- 'parms$gpspline( t, parms ) * gpm * parms$maleX'
births['gpf', 'gpm'] <- 'parms$gpspline( t, parms ) * gpf * parms$pgpf2gpm'
births['gpf', 'msm'] <- 'parms$gpspline( t, parms ) * gpf * (1-parms$pgpf2gpm)'
births['src', 'src'] <- '.5*SRCSIZE^2/parms$srcNe'
migs['src', 'gpm'] <- 'parms$import * gpm'
migs['src', 'gpf'] <- 'parms$import * gpf'
migs['src', 'msm'] <- 'parms$import * msm'
migs['gpm', 'src'] <- 'parms$import * gpm'
migs['gpf', 'src'] <- 'parms$import * gpf'
migs['msm', 'src'] <- 'parms$import * msm'
deaths['msm'] <- 'GAMMA * msm'
deaths['gpf'] <- 'GAMMA * gpf'
deaths['gpm'] <- 'GAMMA * gpm'
deaths['src'] <- '.5*SRCSIZE^2/parms$srcNe'
dm <- build.demographic.process(births, deaths = deaths, parameterNames = names(THETA), rcpp = FALSE, sde = FALSE)
quartz()
show.demographic.process.mod( dm, x0 = X0, t0 = 1978, t1 = 2014, theta = THETA )
library(treedater)
library(devtools)
install_github("mrc-ide/skygrowth")
library(skygrowth)
library(ape)
library(ggplot2)
load(system.file('NY_flu.rda', package='skygrowth'))
(tr <- NY_flu) # NOTE branch lengths in weeks  / 13 years in all
tr
tr$edge.length
tr$tip.label
plot(tr)
quartz()
plot(tr)
fit <- skygrowth.map(tr
,res = 24*13  # Ne changes every 2 weeks
,tau0 = .1    # Smoothing parameter. If prior is not specified, this will also set the scale of the prior
)
plot(fit)
?skygrowth.map
fit
library(phylodyn)
install.packages("phylodyn")
install_github("mdkarcher/phylodyn")
library(phylodyn)
b0 <- BNPR(tr)
install.packages("INLA", repos="https://www.math.ntnu.no/inla/R/stable")
b0 <- BNPR(tr)
b0
plot_BNPR(b0)
mcmcfit <- skygrowth.mcmc( tr, res = 24*13, tau0=.1 )
plot( mcmcfit )
mcmcfit
plot( mcmcfit )  + scale_y_log10(limits=c(.01, 1e5))
fit.t <- skygrowth.map(tr
,res = 50  # Ne changes every 2 weeks
,tau0 = .1    # Smoothing parameter. If prior is not specified, this will also set the scale of the prior
)
plot(fit)
growth.plot( mcmcfit )
mcmcfit
install_github("mdkarcher/phylodyn", build_vignettes = TRUE)
library(phylodyn)
library(senegalHIVmodel)
tree.all <- read.tree(system.file("data/bindTree_CGR_GTR+Gp12+3_droppedTip.tre", package = "senegalHIVmodel"))
str(tree.all)
tree.all
SN.data <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
CGR.data <-  read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
all_data <- organize_metadata(CGR.data, SN.data)
head(all_data)
all_data
str(all_data)
?organize_metadata_bySubtype
all_data <- organize_metadata(CGR.data, SN.data)
?drop.tip
match(all_data$tip.name, tree.all$tip.label)
str(all_data)
only_msm <- subset(all_data, States == "msm")
str(only_msm)
only_msm$States <- as.character(only_msm$States)
only_msm$States <- as.factor(only_msm$States)
str(only_msm)
only_msm
str(subset(all_data, States != "msm"))
tree_gp_src <- drop.tip(tree.all, tip = only_msm$tip.name)
tree_gp_src
quartz()
plot(tree_gp_src)
plot(tree_gp_src)
?BNPR
?skygrowth.map
str(SN.data)
sort(unique(SN.data$Year))
sort(unique(CGR.data$Year))
fit <- skygrowth.map(tree_gp_src)
plot(fit)
e-1
e-01
1e-01
fit <- skygrowth.map(tree_gp_src, tau0 = 0.1)
plot(fit)
only_src <- subset(all_data, States == "src")
only_src$States <- as.character(only_src$States)
only_src$States <- as.factor(only_src$States)
tree_gp <- drop.tip(tree_gp_src, tip = only_src$tip.name)
tree_gp
fit <- skygrowth.map(tree_gp, tau0 = 0.1)
plot(fit)
fit <- skygrowth.map(tree_gp, tau0 = 0.1, res = 10)
plot(fit)
fit <- skygrowth.map(tree_gp, tau0 = 0.1, res = 100)
plot(fit)
fit <- skygrowth.map(tree_gp, tau0 = 0.1, res = 36)
plot(fit)
fit <- skygrowth.map(tree_gp)
plot(fit)
b0 <- BNPR(tree_gp)
plot_BNPR(b0)
?BNPR
plot(tree_gp)
?multi2di
teste=multi2di(tree_gp)
teste
b0 <- BNPR(teste)
teste=di2multi(tree_gp)
b0 <- BNPR(teste)
plot(teste)
b0 <- BNPR(tree_gp_src)
b0 <- BNPR(tree_gp_src)
plot_BNPR(b0)
par(mfrow=c(1,2))
par(mfrow=c(2,2))
fit1 <- skygrowth.map(tree_gp_src, tau0 = 0.1)
fit2 <- skygrowth.map(tree_gp, tau0 = 0.1)
plot(fit1, title="gp and src")
quartz()
par(mfrow=c(2,2))
plot(fit1, title="gp and src")
plot(fit2, title="gp")
plot(fit1)  + ggtitle("gp and src")
par(mfrow=c(2,2))
plot(fit1)  + ggtitle("gp and src")
quartz()
plot(fit2)  + ggtitle("gp")
fit3 <- skygrowth.mcmc(tree_gp_src, tau0=.1 )
quartz()
plot(fit3)  + ggtitle("mcmc gp and src")
fit3 <- skygrowth.mcmc(tree_gp_src)
quartz()
plot(fit3)
fit3 <- skygrowth.mcmc(tree_gp_src, tau0 = 0.4)
quartz()
plot(fit3)
fit3 <- skygrowth.mcmc(tree_gp_src, tau0 = 0.1)
fit4 <- skygrowth.mcmc(tree_gp, tau0 = 0.1)
quartz()
plot(fit4)  + ggtitle("mcmc gp")
tree_gp
tree_gp_src
all_data
View(all_data)
tree.all <- read.tree(system.file("data/bindTree_CGR_GTR+Gp12+3_droppedTip.tre", package = "senegalHIVmodel"))
all.data.cgr <- read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
all.data.SN <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
all_data <- organize_metadata(all.data.cgr, all.data.SN)
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
all_data
sampleStates
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm[all_data$States == "gpm"] <- 1
gpm[all_data$States == "gpm"] <- 1
gpf[all_data$States == "gpf"] <- 1
msm[all_data$States == "msm"] <- 1
src[all_data$States == "src"] <- 1
sampleStates <- cbind(gpm, gpf, msm, src)
all_data <- organize_metadata(all.data.cgr, all.data.SN)
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm
gpm[all_data$States == "gpm"] <- 1
gpf[all_data$States == "gpf"] <- 1
msm[all_data$States == "msm"] <- 1
src[all_data$States == "src"] <- 1
sampleStates <- cbind(gpm, gpf, msm, src)
rownames(sampleStates) <- all_data$tip.name
sampleStates
View(sampleStates)
all_data$tip.name[all_data$tip.name == "AJ287009"]
all_data$tip.name == "AJ287009"
all_data$tip.name
all_data$tip.name[all_data$tip.name == "AJ287009.02_AG.SN.1998"]
all_data$tip.name == "AJ287009.02_AG.SN.1998"
all_data$tip.name[all_data$tip.name == "AJ287009.B.SN.1998"]
mcmcfit <- skygrowth.mcmc( tr, res = 24*13, tau0=.1 )
tr
mcmcfit <- skygrowth.mcmc(tr, res = 24*13, tau0=.1 )
quartz()
plot( mcmcfit )
quartz()
plot( mcmcfit )  + scale_y_log10(limits=c(.01, 1e5))
1e-01
1e+01
fit
all_data
sort(unique(SN.data$Year))
plot(fit3) + scale_x(limits=c(-30, 0))
plot(fit3) + xlim(-30,0)
quartz()
plot(fit3) + xlim(-30,0)
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e4))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-40,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-40,0) + ylim(1, 1e6)
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e4))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
1e+1
1e+2
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(100, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1e+2, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(5, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(3, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(2, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
