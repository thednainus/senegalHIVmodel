library(ape)
B.dtr_mod <- B.dtr
B.dtr_mod$tip.label <- B.df$beast_tip[match(B.dtr_mod$tip.label, B.df$tip)]
# Reading metadata for Senegal only samples and close global reference (CGR) samples
SN.data <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
CGR.data <-  read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
# Metadata for Senegal sequences
B.SN <- subset(SN.data, Subtype == "B")
C.SN <- subset(SN.data, Subtype == "C")
AG.SN <- subset(SN.data, Subtype == "02_AG")
# Metadata for CGR sequences
B.CGR <- subset(CGR.data, Subtype == "B")
C.CGR <- subset(CGR.data, Subtype == "C")
AG.CGR <- subset(CGR.data, Subtype == "02_AG")
##### subtype B ########
B.SN.data <- data_format(B.SN, "SN")
B.SN.df <- B.SN.data[[1]]
B.missing_sample <- B.SN.data[[2]]
B.CGR.data <- data_format(B.CGR, "CGR")
library(senegalHIVmodel)
# Reading metadata for Senegal only samples and close global reference (CGR) samples
SN.data <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
CGR.data <-  read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
# Metadata for Senegal sequences
B.SN <- subset(SN.data, Subtype == "B")
C.SN <- subset(SN.data, Subtype == "C")
AG.SN <- subset(SN.data, Subtype == "02_AG")
# Metadata for CGR sequences
B.CGR <- subset(CGR.data, Subtype == "B")
C.CGR <- subset(CGR.data, Subtype == "C")
AG.CGR <- subset(CGR.data, Subtype == "02_AG")
##### subtype B ########
B.SN.data <- data_format(B.SN, "SN")
B.SN.df <- B.SN.data[[1]]
B.missing_sample <- B.SN.data[[2]]
B.CGR.data <- data_format(B.CGR, "CGR")
B.CGR.df <- B.CGR.data[[1]]
B.CGR.missing_sample <- B.CGR.data[[2]]
# Dataframe for the missing sample date
B.missing_sample.df <- rbind(B.missing_sample[c("tip","lower","upper")],
B.CGR.missing_sample[c("tip","lower","upper")])
# adding a middle point to the samples that have missing data in a column named "decimal"
B.missing_sample.df["decimal"] <- (B.missing_sample.df$lower
+ B.missing_sample.df$upper)/2
# Dataframe containg info for Senegal and CGR sequences. Some values in the
# decimal colum will be NA
B.df <- rbind(B.SN.df[c("Accession_number","tip","decimal")],
B.CGR.df[c("Accession_number","tip","decimal")])
B.df$decimal <- as.character(B.df$decimal)
B.df$decimal <- as.numeric(B.df$decimal)
dec.na <- is.na(B.df$decimal)
dec.na
# Replaces the values in which decimal = NA, to a middle point between lower and
# upper bounds
B.df$decimal[dec.na] <- B.missing_sample.df$decimal[match(B.missing_sample.df$tip,
B.df$tip[dec.na])]
# create the tips for BEAST analysis, in which the dating is the collection date
# as decimal values, i.e. 1998.457
B.df["beast_tip"] <- apply(B.df, 1, replace_values)
teste <- B.df
teste["phydyn_tip"] <- paste(teste$beast_tip,
all_data$States[match(teste$tip, all_data$tip.name)],
sep= "_")
# Reads metadata that contain info for the CGR (close global reference) sequences
# CGRs are referred in the mathematical model as src (source) data
# These are HIV sequences that are from other countries and not from Senegal
all.data.cgr <- read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
# Reads all metadata for HIV sequences from Senegal
all.data.SN <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
# organize metadata in 2 columns.
# the first column is the sequence names
# the second colum is the state (gpf, gpm, msm, or src) of each sequences
all_data <- organize_metadata(all.data.cgr, all.data.SN)
teste
teste["phydyn_tip"] <- paste(teste$beast_tip,
all_data$States[match(teste$tip, all_data$tip.name)],
sep= "_")
teste
# create the tips for BEAST analysis, in which the dating is the collection date
# as decimal values, i.e. 1998.457
B.df["beast_tip"] <- apply(B.df, 1, replace_values)
B.df
B.df["phydyn_tip"] <- paste(B.df$beast_tip,
all_data$States[match(B.df$tip, all_data$tip.name)],
sep= "_")
B.df
# Read fasta alignment for subtype B
B.seq <- read.FASTA("~/Box Sync/Senegal/HIV_myDesktop/data/B/additional_data/sequences_and_alignments/no_duplicates/by_codon/forBEAST/masked_B_plus_additional_seq_CGR_noDups_ali.fasta")
B.seq_mod <- B.seq
# Replaces the tip names in the sequence file to the names
# containing ages as decimal values
names(B.seq_mod) <- B.df$beast_tip[match(names(B.seq) , B.df$tip)]
names(B.seq_mod)
names(B.seq_mod) <- B.df$phydyn_tip[match(names(B.seq) , B.df$tip)]
B.seq_mod
B.seq_mod <- B.seq
names(B.seq_mod)
B.df$beast_tip[match(names(B.seq) , B.df$tip)]
B.df$tip
# Replaces the tip names in the sequence file to the names
# containing ages as decimal values
names(B.seq_mod) <- B.df$beast_tip[match(names(B.seq) , B.df$tip)]
names(B.seq_mod) <- B.df$phydyn_tip[match(names(B.seq) , B.df$tip)]
names(B.seq_mod)
names(B.seq)
#    spline function (gpspline) for the general population (gp)
# msmsp0, msmsp1, msmsp2, msmsploc are the necessary parameters to estimate the
#    spline function (msmspline) for the msm risk group
# maleX is the ratio of infectiouness of males to females
# import is the importation rate of HIV from other countries to Senegal
# srcNe is the
# pmsm2msm is the probability of msm to infect another msm
# pgpf2gpm is the probability of a female from the gp to infect a male from de gp
# initmsm is the initial size of infected msm which is 1
# initgp is the initial size of infected gp which is 1
THETA <- list(
gpsp0 = 6/10,
gpsp1 = 4/10,
gpsp2 = 1/10,
gpsploc = 1987,
msmsp0 = 4/10,
msmsp1 = 4/10,
msmsp2 = 2/10,
msmsploc = 1995,
maleX = 1.02,
import = 1/20,
srcNe = 1/10,
gpspline = function( t, parms ){
if (t < T0 ) return( parms$gpsp0 )
if (t > T1) return (parms$gpsp2)
with(parms, aspline( x = c(T0, gpsploc, T1), y=c(gpsp0, gpsp1, gpsp2) , xout = t)$y)
},
msmspline  = function( t, parms){
if (t < T0 ) return( parms$msmsp0 )
if (t > T1) return ( parms$msmsp2 )
with(parms, aspline( x = c(T0, msmsploc, T1), y=c(msmsp0, msmsp1, msmsp2) , xout = t)$y)
},
pmsm2msm = 0.85,
pgpf2gpm = 0.85,
initmsm = 1,
initgp = 1
)
# arbitrary large number > A(t) forall t
SRCSIZE <<- 1e5
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA$initgp/2),
gpf = unname(THETA$initgp/2),
msm = unname(THETA$initmsm),
src = SRCSIZE)
# Because there are 4 demes in this model, the birth matrix is a 4 x 4 matrix
# Each element in the matrix is a string that will be passed as R code
births['msm', 'msm'] <- 'parms$msmspline(t, parms) * msm * parms$pmsm2msm'
births['msm', 'gpf'] <- 'parms$msmspline(t, parms) * msm * (1-parms$pmsm2msm)'
library(senegalHIVmodel)
library(BayesianTools)
library(akima)
library(phydynR)
library(senegalHIVmodel)
# print R session Info. List R version and loaded packages,
# and information o operational sytem (OS)
sessionInfo()
# Choose and set a seed for all analysis.
# Helpful for reproducing results
seed <- as.integer(runif(n = 1, min = 1, max = 10000))
message(seed)
set.seed(seed)
# gpm = general population males
# gpf = general population females
# msm = man that have sex with other man
# src = source (sequences closely related to population being studies by that are from other countries)
demes <- c('gpm', 'gpf', 'msm', 'src')
# Sets the equations of the model (birth, death and migration rates are pre-filled with zeros)
eqns <- setup.model.equations(demes)
attach(eqns)
# These are the values used for the simulations
# Initial time for simulations
T0 <- 1978
# Final time for simulations
T1 <- 2014
# Duration of infection. In our model we assumed 1 stage of infection
GAMMA <- 1/10
#    spline function (gpspline) for the general population (gp)
# msmsp0, msmsp1, msmsp2, msmsploc are the necessary parameters to estimate the
#    spline function (msmspline) for the msm risk group
# maleX is the ratio of infectiouness of males to females
# import is the importation rate of HIV from other countries to Senegal
# srcNe is the
# pmsm2msm is the probability of msm to infect another msm
# pgpf2gpm is the probability of a female from the gp to infect a male from de gp
# initmsm is the initial size of infected msm which is 1
# initgp is the initial size of infected gp which is 1
THETA <- list(
gpsp0 = 6/10,
gpsp1 = 4/10,
gpsp2 = 1/10,
gpsploc = 1987,
msmsp0 = 4/10,
msmsp1 = 4/10,
msmsp2 = 2/10,
msmsploc = 1995,
maleX = 1.02,
import = 1/20,
srcNe = 1/10,
gpspline = function( t, parms ){
if (t < T0 ) return( parms$gpsp0 )
if (t > T1) return (parms$gpsp2)
with(parms, aspline( x = c(T0, gpsploc, T1), y=c(gpsp0, gpsp1, gpsp2) , xout = t)$y)
},
msmspline  = function( t, parms){
if (t < T0 ) return( parms$msmsp0 )
if (t > T1) return ( parms$msmsp2 )
with(parms, aspline( x = c(T0, msmsploc, T1), y=c(msmsp0, msmsp1, msmsp2) , xout = t)$y)
},
pmsm2msm = 0.85,
pgpf2gpm = 0.85,
initmsm = 1,
initgp = 1
)
# arbitrary large number > A(t) forall t
SRCSIZE <<- 1e5
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA$initgp/2),
gpf = unname(THETA$initgp/2),
msm = unname(THETA$initmsm),
src = SRCSIZE)
# Because there are 4 demes in this model, the birth matrix is a 4 x 4 matrix
# Each element in the matrix is a string that will be passed as R code
births['msm', 'msm'] <- 'parms$msmspline(t, parms) * msm * parms$pmsm2msm'
births['msm', 'gpf'] <- 'parms$msmspline(t, parms) * msm * (1-parms$pmsm2msm)'
births['gpm', 'gpf'] <- 'parms$gpspline(t, parms) * gpm * parms$maleX'
births['gpf', 'gpm'] <- 'parms$gpspline(t, parms) * gpf * parms$pgpf2gpm'
births['gpf', 'msm'] <- 'parms$gpspline(t, parms) * gpf * (1-parms$pgpf2gpm)'
# f = (1/2)*(Y^2)/Ne
births['src', 'src'] <- '0.5 * SRCSIZE^2 / parms$srcNe'
# Migrations is also a 4 x 4 matrix because we have 4 demes
migs['src', 'gpm'] <- 'parms$import * gpm'
migs['src', 'gpf'] <- 'parms$import * gpf'
migs['src', 'msm'] <- 'parms$import * msm'
migs['gpm', 'src'] <- 'parms$import * gpm'
migs['gpf', 'src'] <- 'parms$import * gpf'
migs['msm', 'src'] <- 'parms$import * msm'
# Deaths is a vector that showed in which rate a lineage dies
deaths['msm'] <- 'GAMMA * msm'
deaths['gpf'] <- 'GAMMA * gpf'
deaths['gpm'] <- 'GAMMA * gpm'
deaths['src'] <- '0.5 * SRCSIZE^2 / parms$srcNe'
#sde = FALSE means that an ordinary differential equation model will be constructed
# build the demographic process to be used in the coalescent analysis
dm <- build.demographic.process(births = births,
deaths = deaths,
migrations = migs,
parameterNames = names(THETA),
rcpp = FALSE,
sde = FALSE)
dm
o <- dm( x0 = X0, t0 = 1980, t1 = 2014, theta = THETA )[[5]]
print(o)
library(senegalHIVmodel)
library(ape)
?read.nexus
?read.nexus.data
B.teste <- read.nexus("inst/data/alignments/B_SN_CGRphydyn.nexus")
B.teste <- read.nexus.data("inst/data/alignments/B_SN_CGRphydyn.nexus")
B.teste
str(B.teste)
class(B.teste)
head(B.teste)
names(B.teste)
ages=readRDS("inst/data/bindTree_CGR_GTR+Gp12+3_droppedTip_sts.RDS")
sort(ages)
2014.288 - 1939.38614056425
2014.288 - 1850
2014.288 - 1930
devtools::document()
library(senegalHIVmodel)
?bindTree_CGR_GTR+Gp12+3_droppedTip_phydynBeast
?bindTree_CGR_GTR-plus-Gp12-plus-3_droppedTip_phydynBeast
devtools::document()
library(senegalHIVmodel)
?bindTree_for_phydynBeast
library(senegalHIVmodel)
# laad the mathematical model
source("analyses/scripts/model.R")
#load the data that will be used in the subsequent analysis
source("analyses/scripts/load_data.R")
# This object function will receive the proposals of the MCMC (Markov chain Monte Carlo).
# The reason of using an object function is to make it easier to change the
# values of the parameters to be estimated in THETA.
# Note that not all parameters listed in THETA will be estimated
obj_fun <- function(parameters){
# we use unname here because "parameters" can be as vectors or matrix, and
# sometimes it comes with column names, which I chose to remove these column names
# in here.
parameters <- unname(parameters)
# add the values of THETA to a new variable named THETA.new
THETA.new <- THETA
# change the values in THETA.new to the new proposals that will be evaluated
THETA.new$gpsp0 <- parameters[1]
THETA.new$gpsp1 <- parameters[2]
THETA.new$gpsp2 <- parameters[3]
THETA.new$gpsploc <- parameters[4]
THETA.new$msmsp0 <- parameters[5]
THETA.new$msmsp1 <- parameters[6]
THETA.new$msmsp2 <- parameters[7]
THETA.new$msmsploc <- parameters[8]
THETA.new$import <- parameters[9]
THETA.new$srcNe <- parameters[10]
THETA.new$pmsm2msm <- parameters[11]
THETA.new$pgpf2gpm <- parameters[12]
THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.tree,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3,
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 41)
return(mll)
}
# Specify a density function to be used in the prior especification (see below)
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 20, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/10, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/10, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
# Create sampling, this is optional but recommended because the MCMCs can generate automatic starting
# conditions if this is provided
sampler <-  function(n=1){
d1 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp0
d2 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp1
d3 = rgamma(n, shape = 3, rate = 3/0.1) #gpsp2
d4 = runif(n, min = 1978, max = 2014) #gpsploc
d5 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp0
d6 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp1
d7 = rgamma(n, shape = 3, rate = 3/0.1) #msmsp2
d8 = runif(n, min = 1978, max = 2014) #msmsploc
d9 = rexp(n, rate = 30) #import
d10 = rexp(n, rate = 20) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = rexp(n, rate = 1/10) #initmsm
d14 = rexp(n, rate = 1/10) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
n=10000
d3 = rgamma(n, shape = 3, rate = 3/0.1)
plot(density(d3))
mean(d3)
# runZ below is the run used for previous model (when not estimating initial population size, and using maleX=2)
#runZ <- readRDS(system.file("data/outDEZs_37147513_0_18000_1.rds", package = "senegalHIVmodel"))
# runZ below is the run used for new model (when estimating initial population size, and using maleX=1.02)
#runZ <- readRDS("run_for_zMatriz.rds")
#runZ <- readRDS("mayberun_for_zMatriz.rds")
#The run below was generated using a zMatrix populated with the run mayberun_for_zMatriz.rds
# and using a sample starting from 15000
#runZ <- readRDS("run2_with_zMatrix.RDS")
# Trying this new run for a z matrix
#runZ <- readRDS("~/Box Sync/tests/linearJobs/out_38046926.rds")
runZ <- readRDS("newPrior.rds")
# Get a good sample (the run above is not good, however it can provide a good Z matrix)
# For more information on this: https://github.com/florianhartig/BayesianTools/issues/79
x <- getSample(runZ, start=4000)
quartz()
par(ask=T)
plot(runZ,start=4000)
summary(runZ,start=4000)
# Get the range for the parameter estimates for the previous run
rangePost = apply(x, 2, range)
rangePost
rangePost[1,2]
rangePost[2,2]
rangePost[1,2] <- 0.05
rangePost[2,2] <- 0.7
rangePost
#get unique values of x
u_x <- unique(x)
#cretae new Z matrix based on previous run
# before I was estimating 12 parameters (hence ncol=12)
#newZ = matrix(runif(1500, rangePost[1,], rangePost[2,]), ncol = 12, byrow = T)
# now I am estimating 14 parameters (hence ncol=14)
newZ = matrix(runif(1960, rangePost[1,], rangePost[2,]), ncol = 14, byrow = T)
# Because I will run several analysis in parallel, and to avoid the initial values to be identical
# I will provide as argument position 1 (pos1), position 2 (pos2), and position 3 (pos3)
# from the unique values of x (u_x)
pos1=1
pos2=100
pos3=446
iter=6000 # number of iterations
startValue =  u_x[c(pos1, pos2, pos3), ]
startValue
startValue[2,]
startValue[,2]
startValue[,2] <- 0.1
startValue
settings = list(Z = newZ, startValue =  startValue, nrChains = 1, iterations = iter, thin = 1)
settings
rangePost
# Create bayesianSetup
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
# Create prior (necessary for the BayesianTools package)
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0, 0, 0, 1978, 0, 0, 0, 1978, 0, 0.0001, 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 0.30, 1, 1, 300, 300))
settings = list(Z = newZ, startValue =  startValue, nrChains = 1, iterations = iter, thin = 1)
settings
# Create bayesianSetup
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
saveRDS(outZ, "z_andInitialValues2.RDS")
?render
render("vignettes/pdfSenegalHIVmodel.Rmd", "pdf_document")
library(rmarkdown)
render("vignettes/pdfSenegalHIVmodel.Rmd", "pdf_document")
r1=readRDS("z_andInitialValues.RDS")
r2=readRDS("z_andInitialValues.RDS")
r3=readRDS("~/Box Sync/Senegal/mcmc_new_model/new_prior/new_version_phydyn/zMatrix/out_38231110.rds")
quartz()
plot(r1)
par(ask=T)
plot(r1)
plot(r1,start=1000)
summary(r1,start=1000)
library(BayesianTools)
r1.s=getSample(r1, start=1000,parametersOnly = F)
ri.s.df <- as.data.frame(r1.s)
r1.s.df <- as.data.frame(r1.s)
r1.s.df[r1.s.df$Llikelihod]
r1.s.df[r1.s.df$Llikelihod > 0]
r1.s.df[,r1.s.df$Llikelihod > 0]
r1.s.df[r1.s.df$Llikelihod > 0,]
unique(r1.s.df[r1.s.df$Llikelihod > 0,])
summary(r1.s.df[r1.s.df$Llikelihod > 0,])
plot(r2)
plot(r2,start=1000)
summary(r2,start=1000)
summary(r1,start=1000)
r2=readRDS("z_andInitialValues2.RDS")
plot(r2)
plot(r2,start=1000)
summary(r2,start=1000)
plot(r3)
summary(r3,start=1000)
r3.s=getSample(r3, start=1000,parametersOnly = F)
r3.s[,16]
sort(unique(r3.s[,16]))
r2.s=getSample(r2, start=1000,parametersOnly = F)
sort(unique(r2.s[,16]))
unique(r2.s[,16]
)
r2.s[,16])
r2.s[,16]
r2.s
plot(r2)
r2.s=getSample(r2,parametersOnly = F)
r2.s[,16]
sort(r2.s[,16])
sort(unique(r2.s[,16]))
r1.s[,16]
unique(r1.s[,16])
r1.s
r1.s[1:14]
r1.s[,1:14]
unique(r1.s[,1:14])
u_x=unique(r1.s[,1:14])
str(u_x)
summary(r3,start=1000)
summary(r3,start=1000)
summary(r1,start=1000)
r1=readRDS("z_andSuperHighLn.RDS")
r2=readRDS("z_andSuperHighLn2.RDS")
plot(r1)
plot(r2)
summary(r1)
summary(r2)
summary(r1,start=1000)
summary(r2,start=1000)
r1.s=getSample(r1, parametersOnly = F)
r2.s=getSample(r2, parametersOnly = F)
r1.s[,16]
sort(r1.s[,16])
sort(unique(r1.s[,16]))
sort(unique(r1.s[,16])) > 0
sort(unique(r1.s[,16])>0)
sort(unique(r1.s[,16]>0))
