plot(fit2, title="gp")
plot(fit1)  + ggtitle("gp and src")
par(mfrow=c(2,2))
plot(fit1)  + ggtitle("gp and src")
quartz()
plot(fit2)  + ggtitle("gp")
fit3 <- skygrowth.mcmc(tree_gp_src, tau0=.1 )
quartz()
plot(fit3)  + ggtitle("mcmc gp and src")
fit3 <- skygrowth.mcmc(tree_gp_src)
quartz()
plot(fit3)
fit3 <- skygrowth.mcmc(tree_gp_src, tau0 = 0.4)
quartz()
plot(fit3)
fit3 <- skygrowth.mcmc(tree_gp_src, tau0 = 0.1)
fit4 <- skygrowth.mcmc(tree_gp, tau0 = 0.1)
quartz()
plot(fit4)  + ggtitle("mcmc gp")
tree_gp
tree_gp_src
all_data
View(all_data)
tree.all <- read.tree(system.file("data/bindTree_CGR_GTR+Gp12+3_droppedTip.tre", package = "senegalHIVmodel"))
all.data.cgr <- read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
all.data.SN <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
all_data <- organize_metadata(all.data.cgr, all.data.SN)
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
all_data
sampleStates
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm[all_data$States == "gpm"] <- 1
gpm[all_data$States == "gpm"] <- 1
gpf[all_data$States == "gpf"] <- 1
msm[all_data$States == "msm"] <- 1
src[all_data$States == "src"] <- 1
sampleStates <- cbind(gpm, gpf, msm, src)
all_data <- organize_metadata(all.data.cgr, all.data.SN)
gpm <- gpf <- msm <- src <- rep(0, length(tree.all$tip.label))
gpm
gpm[all_data$States == "gpm"] <- 1
gpf[all_data$States == "gpf"] <- 1
msm[all_data$States == "msm"] <- 1
src[all_data$States == "src"] <- 1
sampleStates <- cbind(gpm, gpf, msm, src)
rownames(sampleStates) <- all_data$tip.name
sampleStates
View(sampleStates)
all_data$tip.name[all_data$tip.name == "AJ287009"]
all_data$tip.name == "AJ287009"
all_data$tip.name
all_data$tip.name[all_data$tip.name == "AJ287009.02_AG.SN.1998"]
all_data$tip.name == "AJ287009.02_AG.SN.1998"
all_data$tip.name[all_data$tip.name == "AJ287009.B.SN.1998"]
mcmcfit <- skygrowth.mcmc( tr, res = 24*13, tau0=.1 )
tr
mcmcfit <- skygrowth.mcmc(tr, res = 24*13, tau0=.1 )
quartz()
plot( mcmcfit )
quartz()
plot( mcmcfit )  + scale_y_log10(limits=c(.01, 1e5))
1e-01
1e+01
fit
all_data
sort(unique(SN.data$Year))
plot(fit3) + scale_x(limits=c(-30, 0))
plot(fit3) + xlim(-30,0)
quartz()
plot(fit3) + xlim(-30,0)
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e4))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-40,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-40,0) + ylim(1, 1e6)
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e4))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
1e+1
1e+2
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(100, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1e+2, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(5, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(3, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(2, 1e6))
plot(fit3) + xlim(-30,0) + scale_y_log10(limits=c(1, 1e6))
library(senegalHIVmodel)
detahc(eqns)
detach(eqns)
source("analyses/scripts/1.model.v2.R")
source("analyses/scripts/2.load_data.v2.R")
obj_fun <- function(parameters){
# we use unname here because "parameters" can be as vectors or matrix, and
# sometimes it comes with column names, which I chose to remove these column names
# in here.
parameters <- unname(parameters)
# add the values of THETA to a new variable named THETA.new
THETA.new <- THETA
# change the values in THETA.new to the new proposals that will be evaluated
THETA.new$gpsp0 <- parameters[1]
THETA.new$gpsp1 <- parameters[2]
THETA.new$gpsp2 <- parameters[3]
THETA.new$gpsploc <- parameters[4]
THETA.new$msmsp0 <- parameters[5]
THETA.new$msmsp1 <- parameters[6]
THETA.new$msmsp2 <- parameters[7]
THETA.new$msmsploc <- parameters[8]
THETA.new$import <- parameters[9]
THETA.new$srcNe <- parameters[10]
THETA.new$pmsm2msm <- parameters[11]
THETA.new$pgpf2gpm <- parameters[12]
THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.tree.dakar,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3, #TODO
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 35)
return(mll)
}
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 1/100, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/3, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/3, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
sampler <-  function(n=1){
d1 = rgamma(n, shape = 4, rate = 4/0.6) #gpsp0
d2 = rgamma(n, shape = 4, rate = 4/0.4) #gpsp1
d3 = rgamma(n, shape = 4, rate = 4/0.1) #gpsp2
d4 = runif(n, min = 1985, max = 2000) #gpsploc
d5 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp0
d6 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp1
d7 = rgamma(n, shape = 4, rate = 4/0.2) #msmsp2
d8 = runif(n, min = 1985, max = 2005) #msmsploc
d9 = runif(n, 1/40, 1/5) #import
d10 = runif(n, 5, 1000) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = runif(n, 1, 3) #initmsm
d14 = runif(n, 1, 3) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0.05, 0.05, 0.05, 1978, 0.05, 0.05, 0.05, 1978, 0, 1., 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 5000, 1, 1, 5, 5))
load("fits.ordered.rda")
sapply(fits.ordered, '[[' , 2 ))
sapply(fits.ordered, '[[' , 2 )
prior
value1 <-  fits.ordered[[3]]$par
value2 <-  fits.ordered[[4]]$par
value3 <-  fits.ordered[[5]]$par
initialValues <- rbind(unname(value1), unname(value2), unname(value3))
initialValues
value1 <-  fits.ordered[[40]]$par
value2 <-  fits.ordered[[39]]$par
value3 <-  fits.ordered[[38]]$par
initialValues <- rbind(unname(value1), unname(value2), unname(value3))
initialValues
value1 <-  fits.ordered[[3]]$par
value2 <-  fits.ordered[[4]]$par
value3 <-  fits.ordered[[5]]$par
initialValues <- rbind(unname(value1), unname(value2), unname(value3))
initialValues
runZ <- readRDS("newModel_comZmatrix.RDS")
quartz()
par(ask=T)
plot(runZ)
plot(runZ,start=800)
out <- readRDS("forZmatrix.rds")
plot(out)
plot(runZ,start=800)
runZ <- readRDS("forZmatrix.rds")
runZ <- readRDS("newModel_comZmatrix.RDS")
summary(runZ, start=800)
summary(out, start=800)
runZ <- readRDS("forZmatrix.rds")
x <- getSample(runZ, start=800)
rangePost = apply(x, 2, range)
u_x <- unique(x)
str(u_x)
newZ = matrix(runif(1960, rangePost[1,], rangePost[2,]), ncol = 14, byrow = T)
iter=6000 # number of iterations
settings = list(Z = newZ, startValue =  initialValues, nrChains = 1, iterations = iter, thin = 1)
settings
out
rm(out)
plot(runZ)
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0.05, 0.05, 0.05, 1978, 0.05, 0.05, 0.05, 1978, 0, 1., 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 5000, 1, 1, 10, 10))
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
THETA <- list(
gpsp0 = 6/10,
gpsp1 = 4/10,
gpsp2 = 1/10,
gpsploc = 1987,
msmsp0 = 4/10,
msmsp1 = 4/10,
msmsp2 = 2/10,
msmsploc = 1995,
maleX = 1.02,
import = 1/20,
srcNe = 20,
gpspline = function( t, parms ){
if (t < T0 ) return( parms$gpsp0 )
if (t > T1) return (parms$gpsp2)
with(parms, pmax(0.025, approx( x = c(T0, gpsploc, T1), y=c(gpsp0, gpsp1, gpsp2) , xout = t, rule = 2)$y) )
},
msmspline  = function( t, parms){
if (t < T0 ) return( parms$msmsp0 )
if (t > T1) return ( parms$msmsp2 )
with(parms, pmax(0.025, approx( x = c(T0, msmsploc, T1), y=c(msmsp0, msmsp1, msmsp2) , xout = t, rule = 2)$y) )
},
pmsm2msm = 0.85,
pgpf2gpm = 0.85,
initmsm = 1,
initgp = 1
)
settings
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
outZ <- runMCMC(bayesianSetup = bayesianSetup,  sampler = "DEzs", settings = settings )
summary(outZ)
quartz()
plot(outZ)
par(ask=T)
plot(outZ)
plot(outZ,start=800)
saveRDS(outZ, "withZMatrix_trial2.RDS")
library(senegalHIVmodel)
library(ape)
tree.all <- read.tree(system.file("data/bindTree_CGR_GTR+Gp12+3_droppedTip.tre", package = "senegalHIVmodel"))
all.data.cgr <- read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
all.data.SN <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
source("analyses/scripts/Model3_noGPM/1.model.v3.R")
source("analyses/scripts/Model3_noGPM/2.load_data.v3.R")
source("analyses/scripts/Model3_noGPM/2.load_data.v3.R")
obj_fun <- function(parameters){
# we use unname here because "parameters" can be as vectors or matrix, and
# sometimes it comes with column names, which I chose to remove these column names
# in here.
parameters <- unname(parameters)
# add the values of THETA to a new variable named THETA.new
THETA.new <- THETA
# change the values in THETA.new to the new proposals that will be evaluated
THETA.new$gpsp0 <- parameters[1]
THETA.new$gpsp1 <- parameters[2]
THETA.new$gpsp2 <- parameters[3]
THETA.new$gpsploc <- parameters[4]
THETA.new$msmsp0 <- parameters[5]
THETA.new$msmsp1 <- parameters[6]
THETA.new$msmsp2 <- parameters[7]
THETA.new$msmsploc <- parameters[8]
THETA.new$import <- parameters[9]
THETA.new$srcNe <- parameters[10]
THETA.new$pmsm2msm <- parameters[11]
THETA.new$pgpf2gpm <- parameters[12]
THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.tree.dakar.noGPM,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3, #TODO
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 35)
return(mll)
}
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 1/100, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/3, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/3, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
sampler <-  function(n=1){
d1 = rgamma(n, shape = 4, rate = 4/0.6) #gpsp0
d2 = rgamma(n, shape = 4, rate = 4/0.4) #gpsp1
d3 = rgamma(n, shape = 4, rate = 4/0.1) #gpsp2
d4 = runif(n, min = 1985, max = 2000) #gpsploc
d5 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp0
d6 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp1
d7 = rgamma(n, shape = 4, rate = 4/0.2) #msmsp2
d8 = runif(n, min = 1985, max = 2005) #msmsploc
d9 = runif(n, 1/40, 1/5) #import
d10 = runif(n, 5, 1000) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = runif(n, 1, 3) #initmsm
d14 = runif(n, 1, 3) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0.05, 0.05, 0.05, 1978, 0.05, 0.05, 0.05, 1978, 0, 1., 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 5000, 1, 1, 300, 300))
load("fits.ordered.rda")
value1 <-  fits.ordered[[1]]$par
value2 <-  fits.ordered[[2]]$par
value3 <-  fits.ordered[[3]]$par
value1
initialValues <- rbind(unname(value1), unname(value2), unname(value3))
initialValues
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
settings = list(iterations = 6000, nrChains = 1, startValue = initialValues, thin = 1)
settings
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
saveRDS(out, "FirstRun_noGPMinTree.rds")
library(ape)
tree.C <- readRDS(system.file("data/trees_by_subtype/dtr.C.CGR.GTR_Gp12+3_byCodon.RDS", package = "senegalHIVmodel"))
tree.C
all.data.cgr <- read.csv(system.file("data/HIV_subtypes_summary_CGR.csv", package = "senegalHIVmodel"))
all.data.SN <- read.csv(system.file("data/HIV_subtypes_summary_SENEGAL_noDups.csv", package = "senegalHIVmodel"))
to_remove <- subset(all.data.SN,
(is.na(Sex) | Risk_group == "Children" |is.na(Risk_group)) &
Subtype == "C")
to_remove
to_remove["tip"] <- paste(to_remove$Accession_number, to_remove$Subtype,
"SN", to_remove$Year, sep = ".")
to_remove
tree.C.tipDropped <- drop.tip(tree.C, to_remove$tip)
length(tree.C.tipDropped$tip.label)
tree.C
str(to_remove)
length(tree.C.tipDropped$tip.label)
all_times <- tree.C$sts
the_names = c(to_remove$tip)
to.remove = which(names(all_times) %in% the_names)
new.times <- all_times[-c(to.remove)]
length(new.times)
library(senegalHIVmodel)
all_data <- organize_metadata(all.data.cgr, all.data.SN)
all.C <- all_data[match(tree.C.tipDropped$tip.label,all_data$tip.name),]
gpm <- gpf <- msm <- src <- rep(0, length(tree.C.tipDropped$tip.label))
gpm[all.C$States == "gpm"] <- 1
gpf[all.C$States == "gpf"] <- 1
msm[all.C$States == "msm"] <- 1
src[all.C$States == "src"] <- 1
sampleStates <- cbind(gpm, gpf, msm, src)
rownames(sampleStates) <- all.C$tip.name
dated.treeC <- DatedTree(phylo = tree.C.tipDropped,
sampleTimes = new.times,
sampleStates = sampleStates,
minEdgeLength = 2/52,
tol = 0.1)
library(phydynR)
dated.treeC <- DatedTree(phylo = tree.C.tipDropped,
sampleTimes = new.times,
sampleStates = sampleStates,
minEdgeLength = 2/52,
tol = 0.1)
source("analyses/scripts/bySubtype/C/1.model.C.R")
source("analyses/scripts/bySubtype/C/2.load_data.C.R")
obj_fun <- function(parameters){
# we use unname here because "parameters" can be as vectors or matrix, and
# sometimes it comes with column names, which I chose to remove these column names
# in here.
parameters <- unname(parameters)
# add the values of THETA to a new variable named THETA.new
THETA.new <- THETA
# change the values in THETA.new to the new proposals that will be evaluated
THETA.new$gpsp0 <- parameters[1]
THETA.new$gpsp1 <- parameters[2]
THETA.new$gpsp2 <- parameters[3]
THETA.new$gpsploc <- parameters[4]
THETA.new$msmsp0 <- parameters[5]
THETA.new$msmsp1 <- parameters[6]
THETA.new$msmsp2 <- parameters[7]
THETA.new$msmsploc <- parameters[8]
THETA.new$import <- parameters[9]
THETA.new$srcNe <- parameters[10]
THETA.new$pmsm2msm <- parameters[11]
THETA.new$pgpf2gpm <- parameters[12]
THETA.new$initmsm <- parameters[13]
THETA.new$initgp <- parameters[14]
# X0 is the initial conditions for the 4 demes (gpf, gpm, msm, src)
X0 <- c(gpm = unname(THETA.new$initgp/2),
gpf = unname(THETA.new$initgp/2),
msm = unname(THETA.new$initmsm) ,
src = 1e5)
# After changing the parameter values to the new proposals, a likelihood is
# calculated with the funtion colik.
# Note that this function uses several global variables, such as, dated.tree, dm, and X0
mll <- colik(tree = dated.treeC,
theta = THETA.new,
demographic.process.model = dm,
x0 = X0,
t0 = 1978,
res = 1e3, #TODO
timeOfOriginBoundaryCondition = FALSE,
AgtY_penalty = 1,
maxHeight = 35)
return(mll)
}
densities <-  function(par){
# d1 to d3 and d5 to d7 I am using a lognormal distribution with mean = R0 = 1.1 and sigma = 1
# d4 and d8 uniform distribution between the start time and the most recent sample
# d9 exponential distribution with mean around 1/30
# d10 exponential distribution with mean around 1/20
d1 = dgamma(par[1], shape = 3, rate = 3/0.1, log = TRUE) #gpsp0
d2 = dgamma(par[2], shape = 3, rate = 3/0.1, log = TRUE) #gpsp1
d3 = dgamma(par[3], shape = 3, rate = 3/0.1, log = TRUE) #gpsp2
d4 = dunif(par[4], min = 1978, max = 2014, log = TRUE) #gpsploc
d5 = dgamma(par[5], shape = 3, rate = 3/0.1, log = TRUE) #msmsp0
d6 = dgamma(par[6], shape = 3, rate = 3/0.1, log = TRUE) #msmsp1
d7 = dgamma(par[7], shape = 3, rate = 3/0.1, log = TRUE) #msmsp2
d8 = dunif(par[8], min = 1978, max = 2014, log = TRUE) #msmsploc
d9 = dexp(par[9], rate = 30, log = TRUE) #import
d10 = dexp(par[10], rate = 1/100, log = TRUE) #srcNe
d11 = dbeta(par[11], shape1 = 16, shape2 = 4, log = TRUE) #pmsm2msm
d12 = dbeta(par[12], shape1 = 16, shape2 = 4, log = TRUE) #pgpf2gpm
d13 = dexp(par[13], rate = 1/3, log = TRUE) #initmsm
d14 = dexp(par[14], rate = 1/3, log = TRUE) #initgp
return(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14)
}
sampler <-  function(n=1){
d1 = rgamma(n, shape = 4, rate = 4/0.6) #gpsp0
d2 = rgamma(n, shape = 4, rate = 4/0.4) #gpsp1
d3 = rgamma(n, shape = 4, rate = 4/0.1) #gpsp2
d4 = runif(n, min = 1985, max = 2000) #gpsploc
d5 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp0
d6 = rgamma(n, shape = 4, rate = 4/0.4) #msmsp1
d7 = rgamma(n, shape = 4, rate = 4/0.2) #msmsp2
d8 = runif(n, min = 1985, max = 2005) #msmsploc
d9 = runif(n, 1/40, 1/5) #import
d10 = runif(n, 5, 1000) #srcNe
d11 = rbeta(n, shape1 = 16, shape2 = 4) #pmsm2msm
d12 = rbeta(n, shape1 = 16, shape2 = 4) #pgpf2gpm
d13 = runif(n, 1, 3) #initmsm
d14 = runif(n, 1, 3) #initgp
return(cbind(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14))
}
prior <- createPrior(density = densities,
sampler = sampler,
lower = c(0.05, 0.05, 0.05, 1978, 0.05, 0.05, 0.05, 1978, 0, 1., 0, 0, 1, 1),
upper = c(1, 1, 1, 2014, 1, 1, 1, 2014, 0.30, 5000, 1, 1, 300, 300))
load("fits.ordered.rda")
value1 <-  fits.ordered[[1]]$par
value2 <-  fits.ordered[[2]]$par
value3 <-  fits.ordered[[3]]$par
initialValues <- rbind(unname(value1), unname(value2), unname(value3))
bayesianSetup <- createBayesianSetup(likelihood = obj_fun , prior = prior)
settings = list(iterations = 6000, nrChains = 1, startValue = initialValues, thin = 1)
settings
out_C <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
quartz()
par(ask=T)
plot(out_C, parametersOnly=F)
saveRDS(out_C, "analyses/scripts/bySubtype/C/Preliminary_results/C_forZmatrix.rds")
runZ <- readRDS("analyses/scripts/bySubtype/C/Preliminary_results/C_forZmatrix.rds")
x <- getSample(runZ, start=800)
rangePost = apply(x, 2, range)
u_x <- unique(x)
str(u_x)
